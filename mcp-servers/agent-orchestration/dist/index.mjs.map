{"version":3,"sources":["../src/index.ts","../src/utils/logger.ts","../src/mcp/server.ts","../../../packages/runtime/src/index.ts","../src/queue/taskQueue.ts","../src/utils/environment.ts","../src/agents/agentManager.ts"],"sourcesContent":["import { serve } from '@hono/node-server';\r\nimport { Hono } from 'hono';\r\nimport { logger } from './utils/logger';\r\nimport { createMCPServer } from './mcp/server';\r\nimport { initializeTaskQueue } from './queue/taskQueue';\r\nimport { initializeAgentManager } from './agents/agentManager';\r\nimport { loadEnvironment } from './utils/environment';\r\n// Removed: import { MCPServer } from '@modelcontextprotocol/runtime'; // No longer needed here\r\n\r\n// Load environment variables\r\nloadEnvironment();\r\n\r\nconst PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : 3020;\r\n\r\nasync function startServer() {\r\n  try {\r\n    logger.info('Starting AI Agent Orchestration MCP Server...');\r\n    \r\n    // Initialize the task queue system\r\n    const taskQueueSystem = await initializeTaskQueue();\r\n    logger.info('Task Queue System initialized');\r\n    \r\n    // Initialize the agent manager\r\n    const agentManager = await initializeAgentManager();\r\n    logger.info('Agent Manager initialized');\r\n    \r\n    // Create the Hono app instance for the MCP server\r\n    // createMCPServer now returns the Hono app directly\r\n    const app = await createMCPServer({\r\n      taskQueueSystem,\r\n      agentManager\r\n    });\r\n    logger.info('MCP Server Hono app created');\r\n    \r\n    // Health check endpoint (already defined in the Hono app returned by createMCPServer)\r\n    // No need to redefine here if it's already part of the returned app.\r\n    // Assuming createMCPServer handles all MCP-specific routes including /mcp/*\r\n    \r\n    // Start the server\r\n    serve({\r\n      fetch: app.fetch, // Use the fetch handler from the created Hono app\r\n      port: PORT\r\n    });\r\n    \r\n    logger.info(`Server listening on port ${PORT}`);\r\n    \r\n    // The initialize method is now called internally within the MCPService constructor\r\n    // No need to call mcpServer.initialize() here anymore\r\n    logger.info('MCP Server initialized and ready to handle requests');\r\n    \r\n  } catch (error) {\r\n    logger.error('Failed to start server:', error);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nstartServer();\r\n\r\n// Handle graceful shutdown\r\nprocess.on('SIGTERM', async () => {\r\n  logger.info('SIGTERM received, shutting down gracefully');\r\n  // Cleanup code here (close connections, etc.)\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('SIGINT', async () => {\r\n  logger.info('SIGINT received, shutting down gracefully');\r\n  // Cleanup code here (close connections, etc.)\r\n  process.exit(0);\r\n});\r\n\r\nprocess.on('uncaughtException', (error) => {\r\n  logger.error('Uncaught exception:', error);\r\n  process.exit(1);\r\n});\r\n\r\nprocess.on('unhandledRejection', (reason) => {\r\n  logger.error('Unhandled rejection:', reason);\r\n  process.exit(1);\r\n});\r\n","import pino from 'pino';\r\n\r\nconst logLevel = process.env.LOG_LEVEL || 'info';\r\n\r\nexport const logger = pino({\r\n  level: logLevel,\r\n  transport: {\r\n    target: 'pino-pretty',\r\n    options: {\r\n      colorize: true,\r\n      translateTime: 'SYS:standard',\r\n      ignore: 'pid,hostname'\r\n    }\r\n  }\r\n});\r\n\r\nexport default logger;\r\n","import { Hono } from 'hono'; // Import Hono\r\nimport { \r\n  MCPService, // Changed from MCPServer\r\n  ServerConfig, // New import\r\n  MCPTool, \r\n  MCPResource \r\n} from '@modelcontextprotocol/runtime';\r\nimport { logger } from '../utils/logger';\r\nimport { TaskQueueSystem, TaskType, TaskPriority } from '../queue/taskQueue';\r\nimport { \r\n  AgentManager, \r\n  AgentCapability, \r\n  AgentType, \r\n  ModelProvider \r\n} from '../agents/agentManager';\r\nimport { z } from 'zod';\r\n\r\ninterface MCPServerDependencies {\r\n  taskQueueSystem: TaskQueueSystem;\r\n  agentManager: AgentManager;\r\n}\r\n\r\n// Define the concrete Agent Orchestration Service\r\nclass AgentOrchestrationService extends MCPService {\r\n  private taskQueueSystem: TaskQueueSystem;\r\n  private agentManager: AgentManager;\r\n\r\n  constructor(app: Hono, config: ServerConfig, dependencies: MCPServerDependencies) {\r\n    super(app, config); // Call parent constructor\r\n    this.taskQueueSystem = dependencies.taskQueueSystem;\r\n    this.agentManager = dependencies.agentManager;\r\n\r\n    // Register tools\r\n    this.registerTools([\r\n      // 1. Execute Agent Tool\r\n      new MCPTool({\r\n        name: 'execute_agent',\r\n        description: 'Execute a specific agent with a prompt',\r\n        inputSchema: z.object({\r\n          agentType: z.enum([\r\n            'brand_context',\r\n            'content_generation',\r\n            'analytics',\r\n            'asset_management',\r\n            'workflow_orchestration'\r\n          ]).describe('The type of agent to execute'),\r\n          prompt: z.string().describe('The prompt or instructions to send to the agent'),\r\n          brandContext: z.string().optional().describe('The brand context to use (optional)'),\r\n          temperature: z.number().min(0).max(2).optional().describe('Temperature for generation (optional)'),\r\n          maxTokens: z.number().positive().optional().describe('Maximum tokens to generate (optional)')\r\n        }),\r\n        func: async (input: any) => { // Explicitly type input\r\n          logger.info(`Executing agent of type ${input.agentType}`);\r\n          \r\n          const agents = this.agentManager.findAgentsByType(input.agentType as AgentType);\r\n          const idleAgents = agents.filter(agent => agent.status === 'idle');\r\n          \r\n          if (idleAgents.length === 0) {\r\n            return {\r\n              success: false,\r\n              error: `No idle agents available of type ${input.agentType}`\r\n            };\r\n          }\r\n          \r\n          const agent = idleAgents[0];\r\n          \r\n          const result = await this.agentManager.executeAgent({\r\n            agentId: agent.id,\r\n            prompt: input.prompt,\r\n            brandContext: input.brandContext,\r\n            temperature: input.temperature,\r\n            maxTokens: input.maxTokens\r\n          });\r\n          \r\n          return {\r\n            success: result.success,\r\n            output: result.output,\r\n            error: result.error,\r\n            usage: result.usage,\r\n            duration: result.duration,\r\n            agentId: result.agentId\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 2. Add Task to Queue Tool\r\n      new MCPTool({\r\n        name: 'add_task_to_queue',\r\n        description: 'Add a task to the orchestration queue',\r\n        inputSchema: z.object({\r\n          taskType: z.enum([\r\n            'content_generation',\r\n            'context_validation',\r\n            'asset_management',\r\n            'analytics_processing',\r\n            'workflow_execution',\r\n            'agent_communication'\r\n          ]).describe('The type of task to add to the queue'),\r\n          payload: z.record(z.any()).describe('The task payload (data needed for the task)'),\r\n          brandContext: z.string().optional().describe('The brand context (optional)'),\r\n          priority: z.enum(['low', 'medium', 'high', 'critical']).optional().describe('Task priority (optional)'),\r\n          dependsOn: z.array(z.string()).optional().describe('Task IDs this task depends on (optional)'),\r\n          timeout: z.number().positive().optional().describe('Task timeout in milliseconds (optional)')\r\n        }),\r\n        func: async (input: any) => { // Explicitly type input\r\n          logger.info(`Adding task of type ${input.taskType} to queue`);\r\n          \r\n          let priorityValue = TaskPriority.MEDIUM;\r\n          \r\n          if (input.priority) {\r\n            switch (input.priority) {\r\n              case 'low':\r\n                priorityValue = TaskPriority.LOW;\r\n                break;\r\n              case 'medium':\r\n                priorityValue = TaskPriority.MEDIUM;\r\n                break;\r\n              case 'high':\r\n                priorityValue = TaskPriority.HIGH;\r\n                break;\r\n              case 'critical':\r\n                priorityValue = TaskPriority.CRITICAL;\r\n                break;\r\n            }\r\n          }\r\n          \r\n          const taskId = await this.taskQueueSystem.addTask( // Use this.taskQueueSystem\r\n            {\r\n              type: input.taskType as TaskType,\r\n              payload: input.payload,\r\n              brandContext: input.brandContext,\r\n              timeout: input.timeout,\r\n              dependsOn: input.dependsOn\r\n            },\r\n            priorityValue\r\n          );\r\n          \r\n          return {\r\n            success: true,\r\n            taskId\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 3. Get Task Status Tool\r\n      new MCPTool({\r\n        name: 'get_task_status',\r\n        description: 'Get the status of a task in the queue',\r\n        inputSchema: z.object({\r\n          taskId: z.string().describe('The ID of the task to check')\r\n        }),\r\n        func: async (input: any) => { // Explicitly type input\r\n          logger.info(`Getting status for task ${input.taskId}`);\r\n          \r\n          const status = await this.taskQueueSystem.getTaskStatus(input.taskId); // Use this.taskQueueSystem\r\n          \r\n          if (status === null) {\r\n            return {\r\n              success: false,\r\n              error: `Task with ID ${input.taskId} not found`\r\n            };\r\n          }\r\n          \r\n          return {\r\n            success: true,\r\n            status\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 4. Get Task Result Tool\r\n      new MCPTool({\r\n        name: 'get_task_result',\r\n        description: 'Get the result of a completed task',\r\n        inputSchema: z.object({\r\n          taskId: z.string().describe('The ID of the task to get results for')\r\n        }),\r\n        func: async (input: any) => { // Explicitly type input\r\n          logger.info(`Getting result for task ${input.taskId}`);\r\n          \r\n          const result = await this.taskQueueSystem.getTaskResult(input.taskId); // Use this.taskQueueSystem\r\n          \r\n          if (result === null) {\r\n            return {\r\n              success: false,\r\n              error: `Task with ID ${input.taskId} not found`\r\n            };\r\n          }\r\n          \r\n          return {\r\n            success: true,\r\n            result\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 5. Register Agent Tool\r\n      new MCPTool({\r\n        name: 'register_agent',\r\n        description: 'Register a new agent with the orchestration layer',\r\n        inputSchema: z.object({\r\n          name: z.string().describe('Name of the agent'),\r\n          type: z.enum([\r\n            'brand_context',\r\n            'content_generation',\r\n            'analytics',\r\n            'asset_management',\r\n            'workflow_orchestration'\r\n          ]).describe('Type of the agent'),\r\n          capabilities: z.array(z.enum([\r\n            'content_generation',\r\n            'context_validation',\r\n            'asset_management',\r\n            'analytics',\r\n            'workflow_orchestration',\r\n            'reasoning',\r\n            'planning',\r\n            'code_generation'\r\n          ])).describe('List of agent capabilities'),\r\n          modelProvider: z.enum([\r\n            'openai',\r\n            'anthropic',\r\n            'ollama',\r\n            'custom'\r\n          ]).describe('The model provider'),\r\n          modelName: z.string().describe('The model name')\r\n        }),\r\n        func: async (input: any) => { // Explicitly type input\r\n          logger.info(`Registering new agent: ${input.name} of type ${input.type}`);\r\n          \r\n          const agent = this.agentManager.registerAgent({ // Use this.agentManager\r\n            name: input.name,\r\n            type: input.type as AgentType,\r\n            capabilities: input.capabilities as AgentCapability[],\r\n            modelProvider: input.modelProvider as ModelProvider,\r\n            modelName: input.modelName\r\n          });\r\n          \r\n          return {\r\n            success: true,\r\n            agentId: agent.id,\r\n            name: agent.name,\r\n            type: agent.type\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 6. Get Agent Stats Tool\r\n      new MCPTool({\r\n        name: 'get_agent_stats',\r\n        description: 'Get statistics about registered agents',\r\n        inputSchema: z.object({}),\r\n        func: async () => { // Explicitly type input\r\n          logger.info('Getting agent statistics');\r\n          \r\n          const stats = this.agentManager.getAgentStats(); // Use this.agentManager\r\n          \r\n          return {\r\n            success: true,\r\n            stats\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 7. Orchestrate Workflow Tool\r\n      new MCPTool({\r\n        name: 'orchestrate_workflow',\r\n        description: 'Orchestrate a multi-step workflow using multiple agents',\r\n        inputSchema: z.object({\r\n          workflowType: z.string().describe('Type of workflow to orchestrate'),\r\n          steps: z.array(z.object({\r\n            agentType: z.enum([\r\n              'brand_context',\r\n              'content_generation',\r\n              'analytics',\r\n              'asset_management',\r\n              'workflow_orchestration'\r\n            ]).describe('Type of agent to use for this step'),\r\n            instruction: z.string().describe('Instruction for this step'),\r\n            outputKey: z.string().describe('Key to store the output under'),\r\n            condition: z.string().optional().describe('Condition to execute this step (optional)')\r\n          })).describe('Steps in the workflow'),\r\n          context: z.record(z.any()).describe('Initial context for the workflow'),\r\n          brandContext: z.string().optional().describe('Brand context (optional)'),\r\n          timeout: z.number().positive().optional().describe('Workflow timeout in milliseconds (optional)')\r\n        }),\r\n        func: async (input: any) => { // Explicitly type input\r\n          logger.info(`Orchestrating workflow of type: ${input.workflowType}`);\r\n          \r\n          // Add task to queue with high priority\r\n          const taskId = await this.taskQueueSystem.addTask( // Use this.taskQueueSystem\r\n            {\r\n              type: TaskType.WORKFLOW_EXECUTION,\r\n              payload: {\r\n                workflowType: input.workflowType,\r\n                steps: input.steps,\r\n                context: input.context\r\n              },\r\n              brandContext: input.brandContext,\r\n              timeout: input.timeout\r\n            },\r\n            TaskPriority.HIGH\r\n          );\r\n          \r\n          return {\r\n            success: true,\r\n            message: 'Workflow orchestration initiated',\r\n            taskId,\r\n            estimatedSteps: input.steps.length\r\n          };\r\n        }\r\n      })\r\n    ]);\r\n\r\n    // Register resources\r\n    this.registerResources([\r\n      // 1. Agents Resource - provides information about all registered agents\r\n      new MCPResource({\r\n        name: 'agents',\r\n        description: 'List of all registered agents and their capabilities',\r\n        schema: z.object({ // Added schema\r\n          count: z.number(),\r\n          agents: z.array(z.object({\r\n            id: z.string(),\r\n            name: z.string(),\r\n            type: z.string(),\r\n            capabilities: z.array(z.string()),\r\n            status: z.string(),\r\n            modelProvider: z.string(),\r\n            modelName: z.string(),\r\n            lastActive: z.union([z.string(), z.undefined()]) // Date might be string after serialization\r\n          }))\r\n        }),\r\n        get: async () => {\r\n          const agents = this.agentManager.getAllAgents().map(agent => ({\r\n            id: agent.id,\r\n            name: agent.name,\r\n            type: agent.type,\r\n            capabilities: agent.capabilities,\r\n            status: agent.status,\r\n            modelProvider: agent.modelProvider,\r\n            modelName: agent.modelName,\r\n            lastActive: agent.lastActive\r\n          }));\r\n          \r\n          return {\r\n            count: agents.length,\r\n            agents\r\n          };\r\n        }\r\n      }),\r\n      \r\n      // 2. Queue Stats Resource - provides statistics about the task queue\r\n      new MCPResource({\r\n        name: 'queue_stats',\r\n        description: 'Statistics about the task queue',\r\n        schema: z.object({ // Added schema\r\n          activeCount: z.number(),\r\n          waitingCount: z.number(),\r\n          completedCount: z.number(),\r\n          failedCount: z.number(),\r\n          avgProcessingTime: z.number()\r\n        }),\r\n        get: async () => {\r\n          return {\r\n            activeCount: 5,\r\n            waitingCount: 12,\r\n            completedCount: 87,\r\n            failedCount: 3,\r\n            avgProcessingTime: 1250 // ms\r\n          };\r\n        }\r\n      })\r\n    ]);\r\n  }\r\n}\r\n\r\n/**\r\n * Create and configure the MCP server instance\r\n */\r\nexport async function createMCPServer(\r\n  dependencies: MCPServerDependencies\r\n): Promise<Hono> { // Return type is now Hono app\r\n  const app = new Hono(); // Create Hono app\r\n\r\n  // Configure the MCP server service\r\n  const config: ServerConfig = {\r\n    name: 'agent-orchestration',\r\n    description: 'AI Agent Orchestration Layer for multi-brand system',\r\n    version: '0.1.0',\r\n  };\r\n  \r\n  // Instantiate the concrete MCPService\r\n  const agentOrchestrationService = new AgentOrchestrationService(app, config, dependencies);\r\n  \r\n  // Initialize the service (if needed, this calls the initialize method on MCPService)\r\n  await agentOrchestrationService.initialize();\r\n\r\n  logger.info('Agent Orchestration MCP Server created and configured');\r\n  \r\n  return app; // Return the Hono app\r\n}\r\n","import { Hono } from 'hono'; // Assuming Hono is the web framework for MCP servers\r\n\r\n// 1. ServerConfig Interface\r\nexport interface ServerConfig {\r\n  name: string;\r\n  description: string;\r\n  version: string;\r\n}\r\n\r\n// 2. MCPTool Class\r\nexport class MCPTool {\r\n  public name: string;\r\n  public description: string;\r\n  public inputSchema: any; // Using 'any' for simplicity, will be Zod schema\r\n  public handler: (input: any, context?: any) => Promise<any>;\r\n\r\n  constructor(options: {\r\n    name: string;\r\n    description: string;\r\n    inputSchema: any;\r\n    func: (input: any, context?: any) => Promise<any>;\r\n  }) {\r\n    this.name = options.name;\r\n    this.description = options.description;\r\n    this.inputSchema = options.inputSchema;\r\n    this.handler = options.func; // Renamed func to handler for consistency\r\n  }\r\n}\r\n\r\n// 3. MCPResource Class\r\nexport class MCPResource {\r\n  public name: string;\r\n  public description: string;\r\n  public schema: any; // Using 'any' for simplicity, will be Zod schema\r\n  public handler: (uri: string, context?: any) => Promise<any>; // For 'get' operation\r\n\r\n  constructor(options: {\r\n    name: string;\r\n    description: string;\r\n    schema: any;\r\n    get: (uri: string, context?: any) => Promise<any>;\r\n  }) {\r\n    this.name = options.name;\r\n    this.description = options.description;\r\n    this.schema = options.schema;\r\n    this.handler = options.get; // Renamed get to handler for consistency\r\n  }\r\n}\r\n\r\n// 4. MCPService Abstract Class\r\nexport abstract class MCPService {\r\n  public name: string;\r\n  public version: string;\r\n  public description: string;\r\n  protected app: Hono; // Hono app instance\r\n\r\n  private tools: MCPTool[] = [];\r\n  private resources: MCPResource[] = [];\r\n\r\n  constructor(app: Hono, config: ServerConfig) {\r\n    this.app = app;\r\n    this.name = config.name;\r\n    this.version = config.version;\r\n    this.description = config.description;\r\n\r\n    // Register basic endpoints for MCP server info\r\n    this.app.get('/mcp/info', (c) => {\r\n      return c.json({\r\n        name: this.name,\r\n        version: this.version,\r\n        description: this.description,\r\n        tools: this.tools.map(tool => ({ name: tool.name, description: tool.description, inputSchema: tool.inputSchema })),\r\n        resources: this.resources.map(resource => ({ name: resource.name, description: resource.description, schema: resource.schema })),\r\n      });\r\n    });\r\n\r\n    // Endpoint for executing tools\r\n    this.app.post('/mcp/tool/:toolName', async (c) => {\r\n      const toolName = c.req.param('toolName');\r\n      const tool = this.tools.find(t => t.name === toolName);\r\n      if (!tool) {\r\n        return c.json({ error: `Tool '${toolName}' not found` }, 404);\r\n      }\r\n      try {\r\n        const input = await c.req.json();\r\n        // Here, you might add Zod validation: tool.inputSchema.parse(input);\r\n        const result = await tool.handler(input);\r\n        return c.json(result);\r\n      } catch (error: any) {\r\n        return c.json({ error: error.message || 'Tool execution failed' }, 500);\r\n      }\r\n    });\r\n\r\n    // Endpoint for accessing resources\r\n    this.app.get('/mcp/resource/:resourceName/:uri*', async (c) => {\r\n      const resourceName = c.req.param('resourceName');\r\n      const uri = c.req.param('uri') || ''; // Provide a default empty string if undefined\r\n      const resource = this.resources.find(r => r.name === resourceName);\r\n      if (!resource) {\r\n        return c.json({ error: `Resource '${resourceName}' not found` }, 404);\r\n      }\r\n      try {\r\n        const result = await resource.handler(uri);\r\n        return c.json(result);\r\n      } catch (error: any) {\r\n        return c.json({ error: error.message || 'Resource access failed' }, 500);\r\n      }\r\n    });\r\n  }\r\n\r\n  // MCP Service methods\r\n  protected registerTools(tools: MCPTool[]): void {\r\n    this.tools.push(...tools);\r\n  }\r\n\r\n  protected registerResources(resources: MCPResource[]): void {\r\n    this.resources.push(...resources);\r\n  }\r\n\r\n  // Methods expected by agent-orchestration (and likely others)\r\n  public async handleHttpRequest(request: any): Promise<any> {\r\n    // This method would typically be used to pass an incoming HTTP request\r\n    // from an external server (like Node.js http server) to the Hono app.\r\n    // For a Hono app, you'd usually use its own server integration.\r\n    // This is a placeholder for direct request handling if needed.\r\n    console.warn(\"handleHttpRequest not fully implemented for Hono-based MCPService.\");\r\n    return { status: 501, body: 'Not Implemented' };\r\n  }\r\n\r\n  public async initialize(): Promise<void> {\r\n    console.log(`${this.name} MCP Service initialized.`);\r\n    // Any service-specific initialization logic\r\n  }\r\n}\r\n\r\n// 5. createServer Function\r\n// This function will create and return an instance of a concrete MCPService.\r\n// For now, it will simply return the Hono app itself, and the MCPService will\r\n// be responsible for setting up its own Hono app. This structure seems more\r\n// aligned with how Hono apps are typically used.\r\nexport function createServer(config: ServerConfig): Hono {\r\n  const app = new Hono();\r\n\r\n  // Basic info endpoint\r\n  app.get('/mcp/info', (c) => {\r\n    return c.json(config);\r\n  });\r\n\r\n  // The actual MCPService instance will be created and configured\r\n  // within each mcp-server package, and its Hono app will be exported.\r\n  // This createServer function might become obsolete or serve a different purpose,\r\n  // e.g., creating a base Hono app instance for the MCPService to use.\r\n  \r\n  // For now, let's keep it simple and assume each MCP server\r\n  // will construct its own Hono app and pass it to MCPService.\r\n  return app;\r\n}\r\n","import { Queue, Worker, Job } from 'bullmq';\r\nimport Redis from 'ioredis';\r\nimport { logger } from '../utils/logger';\r\nimport { getOptionalEnv } from '../utils/environment';\r\n\r\n// Task types supported by the orchestration layer\r\nexport enum TaskType {\r\n  CONTENT_GENERATION = 'content_generation',\r\n  CONTEXT_VALIDATION = 'context_validation',\r\n  ASSET_MANAGEMENT = 'asset_management',\r\n  ANALYTICS_PROCESSING = 'analytics_processing',\r\n  WORKFLOW_EXECUTION = 'workflow_execution',\r\n  AGENT_COMMUNICATION = 'agent_communication'\r\n}\r\n\r\n// Priority levels for tasks\r\nexport enum TaskPriority {\r\n  LOW = 1,\r\n  MEDIUM = 5,\r\n  HIGH = 10,\r\n  CRITICAL = 20\r\n}\r\n\r\n// Task status values\r\nexport enum TaskStatus {\r\n  PENDING = 'pending',\r\n  PROCESSING = 'processing',\r\n  COMPLETED = 'completed',\r\n  FAILED = 'failed',\r\n  RETRYING = 'retrying',\r\n  CANCELLED = 'cancelled'\r\n}\r\n\r\n// Interface for task data\r\nexport interface TaskData {\r\n  type: TaskType;\r\n  payload: Record<string, any>;\r\n  brandContext?: string;\r\n  timeout?: number;\r\n  dependsOn?: string[];\r\n}\r\n\r\n// Interface for task result\r\nexport interface TaskResult {\r\n  success: boolean;\r\n  data?: any;\r\n  error?: string;\r\n}\r\n\r\n// Task Queue System class\r\nexport class TaskQueueSystem {\r\n  private redisClient: Redis;\r\n  private queue: Queue;\r\n  private workers: Map<string, Worker> = new Map();\r\n  private processorMap: Map<TaskType, (job: Job) => Promise<any>> = new Map();\r\n\r\n  constructor() {\r\n    const redisUrl = getOptionalEnv('REDIS_URL', 'redis://localhost:6379');\r\n    \r\n    this.redisClient = new Redis(redisUrl, {\r\n      maxRetriesPerRequest: 3\r\n    });\r\n    \r\n    this.queue = new Queue('agent-orchestration', {\r\n      connection: this.redisClient,\r\n      defaultJobOptions: {\r\n        attempts: 3,\r\n        backoff: {\r\n          type: 'exponential',\r\n          delay: 1000\r\n        },\r\n        removeOnComplete: 100, // Keep the last 100 completed jobs\r\n        removeOnFail: 200 // Keep the last 200 failed jobs\r\n      }\r\n    });\r\n    \r\n    logger.info('Task Queue System created');\r\n  }\r\n\r\n  /**\r\n   * Register a task processor function for a specific task type\r\n   */\r\n  public registerProcessor(\r\n    taskType: TaskType,\r\n    processor: (job: Job) => Promise<any>,\r\n    concurrency = 1\r\n  ): void {\r\n    this.processorMap.set(taskType, processor);\r\n    \r\n    // Create a worker for this task type\r\n    const worker = new Worker(\r\n      'agent-orchestration',\r\n      async (job) => {\r\n        if (job.data.type === taskType) {\r\n          logger.info(`Processing job ${job.id} of type ${taskType}`);\r\n          return processor(job);\r\n        }\r\n        throw new Error(`Worker for ${taskType} received job of type ${job.data.type}`);\r\n      },\r\n      {\r\n        connection: this.redisClient.duplicate(),\r\n        concurrency,\r\n        lockDuration: 30000, // 30 seconds\r\n      }\r\n    );\r\n    \r\n    // Handle worker events\r\n    worker.on('completed', (job) => {\r\n      logger.info(`Job ${job.id} of type ${taskType} completed successfully`);\r\n    });\r\n    \r\n    worker.on('failed', (job, error) => {\r\n      logger.error(`Job ${job?.id} of type ${taskType} failed:`, error);\r\n    });\r\n    \r\n    this.workers.set(taskType, worker);\r\n    logger.info(`Registered processor for task type: ${taskType}`);\r\n  }\r\n\r\n  /**\r\n   * Add a task to the queue\r\n   */\r\n  public async addTask(\r\n    taskData: TaskData,\r\n    priority: TaskPriority = TaskPriority.MEDIUM,\r\n    delay: number = 0\r\n  ): Promise<string> {\r\n    const job = await this.queue.add(taskData.type, taskData, {\r\n      priority,\r\n      delay,\r\n      timeout: taskData.timeout || 60000, // Default timeout of 60 seconds\r\n      jobId: `${taskData.type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\r\n    });\r\n    \r\n    logger.info(`Added job ${job.id} of type ${taskData.type} to queue`);\r\n    return job.id as string;\r\n  }\r\n\r\n  /**\r\n   * Get the status of a task\r\n   */\r\n  public async getTaskStatus(jobId: string): Promise<TaskStatus | null> {\r\n    const job = await this.queue.getJob(jobId);\r\n    \r\n    if (!job) {\r\n      return null;\r\n    }\r\n    \r\n    const state = await job.getState();\r\n    \r\n    switch (state) {\r\n      case 'waiting':\r\n      case 'delayed':\r\n        return TaskStatus.PENDING;\r\n      case 'active':\r\n        return TaskStatus.PROCESSING;\r\n      case 'completed':\r\n        return TaskStatus.COMPLETED;\r\n      case 'failed':\r\n        return TaskStatus.FAILED;\r\n      case 'retrying':\r\n        return TaskStatus.RETRYING;\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the result of a completed task\r\n   */\r\n  public async getTaskResult(jobId: string): Promise<TaskResult | null> {\r\n    const job = await this.queue.getJob(jobId);\r\n    \r\n    if (!job) {\r\n      return null;\r\n    }\r\n    \r\n    // Check if job is completed\r\n    const state = await job.getState();\r\n    if (state !== 'completed') {\r\n      return {\r\n        success: false,\r\n        error: `Job is not completed. Current state: ${state}`\r\n      };\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      data: job.returnvalue\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cancel a pending task\r\n   */\r\n  public async cancelTask(jobId: string): Promise<boolean> {\r\n    const job = await this.queue.getJob(jobId);\r\n    \r\n    if (!job) {\r\n      return false;\r\n    }\r\n    \r\n    const state = await job.getState();\r\n    \r\n    if (state === 'waiting' || state === 'delayed') {\r\n      await job.remove();\r\n      logger.info(`Cancelled job ${jobId}`);\r\n      return true;\r\n    }\r\n    \r\n    logger.warn(`Cannot cancel job ${jobId} in state ${state}`);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Graceful shutdown of the task queue system\r\n   */\r\n  public async shutdown(): Promise<void> {\r\n    logger.info('Shutting down Task Queue System...');\r\n    \r\n    // Close all workers\r\n    for (const [type, worker] of this.workers.entries()) {\r\n      logger.info(`Closing worker for ${type}...`);\r\n      await worker.close();\r\n    }\r\n    \r\n    // Close the queue\r\n    await this.queue.close();\r\n    \r\n    // Close Redis connection\r\n    await this.redisClient.quit();\r\n    \r\n    logger.info('Task Queue System shut down successfully');\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet taskQueueSystem: TaskQueueSystem | null = null;\r\n\r\n/**\r\n * Initialize the task queue system\r\n */\r\nexport async function initializeTaskQueue(): Promise<TaskQueueSystem> {\r\n  if (!taskQueueSystem) {\r\n    taskQueueSystem = new TaskQueueSystem();\r\n    \r\n    // Register default processors here if needed\r\n    // Example:\r\n    // taskQueueSystem.registerProcessor(\r\n    //   TaskType.CONTENT_GENERATION,\r\n    //   async (job) => {\r\n    //     // Process content generation task\r\n    //     return { result: 'Content generated' };\r\n    //   },\r\n    //   2 // Concurrency\r\n    // );\r\n  }\r\n  \r\n  return taskQueueSystem;\r\n}\r\n\r\n/**\r\n * Get the task queue system instance\r\n */\r\nexport function getTaskQueueSystem(): TaskQueueSystem {\r\n  if (!taskQueueSystem) {\r\n    throw new Error('Task Queue System not initialized. Call initializeTaskQueue() first.');\r\n  }\r\n  \r\n  return taskQueueSystem;\r\n}\r\n","import dotenv from 'dotenv';\r\nimport { logger } from './logger';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\n\r\n/**\r\n * Loads environment variables from .env file\r\n * Checks different locations for the .env file\r\n */\r\nexport function loadEnvironment(): void {\r\n  try {\r\n    // Try to load from current directory\r\n    let envResult = dotenv.config();\r\n    \r\n    // If no .env file in current directory, try to load from project root\r\n    if (envResult.error) {\r\n      const rootEnvPath = path.resolve(process.cwd(), '../../.env');\r\n      if (fs.existsSync(rootEnvPath)) {\r\n        envResult = dotenv.config({ path: rootEnvPath });\r\n      }\r\n    }\r\n\r\n    if (envResult.error) {\r\n      logger.warn('No .env file found, using environment variables');\r\n    } else {\r\n      logger.info('Environment variables loaded');\r\n    }\r\n\r\n    // Validate required environment variables\r\n    const requiredEnvVars = [\r\n      // Add any required environment variables here\r\n      // Example: 'DATABASE_URL'\r\n    ];\r\n\r\n    const missingEnvVars = requiredEnvVars.filter(\r\n      (envVar) => !process.env[envVar]\r\n    );\r\n\r\n    if (missingEnvVars.length > 0) {\r\n      logger.warn(\r\n        `Missing required environment variables: ${missingEnvVars.join(', ')}`\r\n      );\r\n    }\r\n  } catch (error) {\r\n    logger.error('Error loading environment variables:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets a required environment variable\r\n * Throws an error if the variable is not set\r\n */\r\nexport function getRequiredEnv(key: string): string {\r\n  const value = process.env[key];\r\n  if (!value) {\r\n    throw new Error(`Required environment variable ${key} is not set`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Gets an optional environment variable with a default value\r\n */\r\nexport function getOptionalEnv(key: string, defaultValue: string): string {\r\n  return process.env[key] || defaultValue;\r\n}\r\n","import { logger } from '../utils/logger';\r\nimport { getOptionalEnv } from '../utils/environment';\r\nimport OpenAI from 'openai';\r\nimport Anthropic from '@anthropic-ai/sdk';\r\nimport fetch from 'node-fetch';\r\n\r\n/**\r\n * Agent capability types\r\n */\r\nexport enum AgentCapability {\r\n  CONTENT_GENERATION = 'content_generation',\r\n  CONTEXT_VALIDATION = 'context_validation',\r\n  ASSET_MANAGEMENT = 'asset_management',\r\n  ANALYTICS = 'analytics',\r\n  WORKFLOW_ORCHESTRATION = 'workflow_orchestration',\r\n  REASONING = 'reasoning',\r\n  PLANNING = 'planning',\r\n  CODE_GENERATION = 'code_generation'\r\n}\r\n\r\n/**\r\n * Agent status values\r\n */\r\nexport enum AgentStatus {\r\n  IDLE = 'idle',\r\n  BUSY = 'busy',\r\n  OFFLINE = 'offline',\r\n  ERROR = 'error'\r\n}\r\n\r\n/**\r\n * Agent type definitions\r\n */\r\nexport enum AgentType {\r\n  BRAND_CONTEXT = 'brand_context',\r\n  CONTENT_GENERATION = 'content_generation',\r\n  ANALYTICS = 'analytics',\r\n  ASSET_MANAGEMENT = 'asset_management',\r\n  WORKFLOW_ORCHESTRATION = 'workflow_orchestration'\r\n}\r\n\r\n/**\r\n * Agent model providers\r\n */\r\nexport enum ModelProvider {\r\n  OPENAI = 'openai',\r\n  ANTHROPIC = 'anthropic',\r\n  OLLAMA = 'ollama',\r\n  CUSTOM = 'custom'\r\n}\r\n\r\n/**\r\n * Agent interface definition\r\n */\r\nexport interface Agent {\r\n  id: string;\r\n  name: string;\r\n  type: AgentType;\r\n  capabilities: AgentCapability[];\r\n  status: AgentStatus;\r\n  modelProvider: ModelProvider;\r\n  modelName: string;\r\n  lastActive?: Date;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Agent registration request\r\n */\r\nexport interface AgentRegistrationRequest {\r\n  name: string;\r\n  type: AgentType;\r\n  capabilities: AgentCapability[];\r\n  modelProvider: ModelProvider;\r\n  modelName: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Agent execution request\r\n */\r\nexport interface AgentExecutionRequest {\r\n  agentId: string;\r\n  prompt: string;\r\n  brandContext?: string;\r\n  temperature?: number;\r\n  maxTokens?: number;\r\n  systemInstructions?: string;\r\n  tools?: any[];\r\n}\r\n\r\n/**\r\n * Agent execution result\r\n */\r\nexport interface AgentExecutionResult {\r\n  agentId: string;\r\n  success: boolean;\r\n  output?: string;\r\n  error?: string;\r\n  usage?: {\r\n    promptTokens: number;\r\n    completionTokens: number;\r\n    totalTokens: number;\r\n  };\r\n  duration?: number;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Type definition for Ollama chat API response\r\n */\r\ninterface OllamaChatResponse {\r\n  message?: {\r\n    content: string;\r\n  };\r\n  usage?: {\r\n    prompt_eval_count: number;\r\n    eval_count: number;\r\n    total_eval_count: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Agent Manager class for managing AI agents\r\n */\r\nexport class AgentManager {\r\n  private agents: Map<string, Agent> = new Map();\r\n  private capabilityIndex: Map<AgentCapability, Set<string>> = new Map();\r\n  private typeIndex: Map<AgentType, Set<string>> = new Map();\r\n  private modelProviderIndex: Map<ModelProvider, Set<string>> = new Map();\r\n\r\n  private openaiClient: OpenAI | undefined;\r\n  private anthropicClient: Anthropic | undefined;\r\n  // private ollamaClient: any; // Placeholder for Ollama client\r\n\r\n  constructor() {\r\n    logger.info('Agent Manager created');\r\n    \r\n    // Initialize capability index\r\n    Object.values(AgentCapability).forEach(capability => {\r\n      this.capabilityIndex.set(capability, new Set<string>());\r\n    });\r\n    \r\n    // Initialize type index\r\n    Object.values(AgentType).forEach(type => {\r\n      this.typeIndex.set(type, new Set<string>());\r\n    });\r\n    \r\n    // Initialize model provider index\r\n    Object.values(ModelProvider).forEach(provider => {\r\n      this.modelProviderIndex.set(provider, new Set<string>());\r\n    });\r\n\r\n    // Initialize OpenAI client\r\n    const openaiApiKey = getOptionalEnv('OPENAI_API_KEY');\r\n    if (openaiApiKey) {\r\n      this.openaiClient = new OpenAI({ apiKey: openaiApiKey });\r\n    } else {\r\n      logger.warn('OPENAI_API_KEY not found. OpenAI agent execution will be simulated.');\r\n    }\r\n\r\n    // Initialize Anthropic client\r\n    const anthropicApiKey = getOptionalEnv('ANTHROPIC_API_KEY');\r\n    if (anthropicApiKey) {\r\n      this.anthropicClient = new Anthropic({ apiKey: anthropicApiKey });\r\n    } else {\r\n      logger.warn('ANTHROPIC_API_KEY not found. Anthropic agent execution will be simulated.');\r\n    }\r\n\r\n    // Initialize Ollama client (placeholder)\r\n    // const ollamaBaseUrl = getOptionalEnv('OLLAMA_BASE_URL', 'http://localhost:11434');\r\n    // if (ollamaBaseUrl) {\r\n    //   this.ollamaClient = new Ollama({ baseUrl: ollamaBaseUrl }); // Assuming an Ollama SDK exists\r\n    // } else {\r\n    //   logger.warn('OLLAMA_BASE_URL not found. Ollama agent execution will be simulated.');\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Register a new agent\r\n   */\r\n  public registerAgent(request: AgentRegistrationRequest): Agent {\r\n    const agentId = `${request.type}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\r\n    \r\n    const agent: Agent = {\r\n      id: agentId,\r\n      name: request.name,\r\n      type: request.type,\r\n      capabilities: request.capabilities,\r\n      status: AgentStatus.IDLE,\r\n      modelProvider: request.modelProvider,\r\n      modelName: request.modelName,\r\n      lastActive: new Date(),\r\n      metadata: request.metadata || {}\r\n    };\r\n    \r\n    this.agents.set(agentId, agent);\r\n    \r\n    // Update indexes\r\n    agent.capabilities.forEach(capability => {\r\n      this.capabilityIndex.get(capability)?.add(agentId);\r\n    });\r\n    \r\n    this.typeIndex.get(agent.type)?.add(agentId);\r\n    this.modelProviderIndex.get(agent.modelProvider)?.add(agentId);\r\n    \r\n    logger.info(`Registered agent ${agentId} of type ${agent.type}`);\r\n    return agent;\r\n  }\r\n\r\n  /**\r\n   * Get an agent by ID\r\n   */\r\n  public getAgent(agentId: string): Agent | undefined {\r\n    return this.agents.get(agentId);\r\n  }\r\n\r\n  /**\r\n   * Find agents by capability\r\n   */\r\n  public findAgentsByCapability(capability: AgentCapability): Agent[] {\r\n    const agentIds = this.capabilityIndex.get(capability) || new Set<string>();\r\n    return Array.from(agentIds)\r\n      .map(id => this.agents.get(id))\r\n      .filter(agent => agent !== undefined) as Agent[];\r\n  }\r\n\r\n  /**\r\n   * Find agents by type\r\n   */\r\n  public findAgentsByType(type: AgentType): Agent[] {\r\n    const agentIds = this.typeIndex.get(type) || new Set<string>();\r\n    return Array.from(agentIds)\r\n      .map(id => this.agents.get(id))\r\n      .filter(agent => agent !== undefined) as Agent[];\r\n  }\r\n\r\n  /**\r\n   * Find idle agents with a specific capability\r\n   */\r\n  public findIdleAgentsByCapability(capability: AgentCapability): Agent[] {\r\n    return this.findAgentsByCapability(capability).filter(\r\n      agent => agent.status === AgentStatus.IDLE\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Execute a task with an agent\r\n   */\r\n  public async executeAgent(request: AgentExecutionRequest): Promise<AgentExecutionResult> {\r\n    const agent = this.agents.get(request.agentId);\r\n    \r\n    if (!agent) {\r\n      return {\r\n        agentId: request.agentId,\r\n        success: false,\r\n        error: `Agent with ID ${request.agentId} not found`\r\n      };\r\n    }\r\n    \r\n    if (agent.status === AgentStatus.BUSY) {\r\n      return {\r\n        agentId: request.agentId,\r\n        success: false,\r\n        error: `Agent ${request.agentId} is busy`\r\n      };\r\n    }\r\n    \r\n    try {\r\n      // Update agent status\r\n      agent.status = AgentStatus.BUSY;\r\n      agent.lastActive = new Date();\r\n      \r\n      logger.info(`Executing agent ${request.agentId} of type ${agent.type}`);\r\n      \r\n      // Implement actual execution logic based on the agent type and model provider\r\n      // For this example, we'll just simulate execution\r\n      const startTime = Date.now();\r\n      \r\n      // Simulate different execution paths based on model provider\r\n      let result: AgentExecutionResult;\r\n      \r\n      switch (agent.modelProvider) {\r\n        case ModelProvider.OPENAI:\r\n          result = await this.executeOpenAI(agent, request);\r\n          break;\r\n        case ModelProvider.ANTHROPIC:\r\n          result = await this.executeAnthropic(agent, request);\r\n          break;\r\n        case ModelProvider.OLLAMA:\r\n          result = await this.executeOllama(agent, request);\r\n          break;\r\n        case ModelProvider.CUSTOM:\r\n          result = await this.executeCustom(agent, request);\r\n          break;\r\n        default:\r\n          result = {\r\n            agentId: agent.id,\r\n            success: false,\r\n            error: `Unsupported model provider: ${agent.modelProvider}`\r\n          };\r\n      }\r\n      \r\n      // Calculate execution duration\r\n      const duration = Date.now() - startTime;\r\n      result.duration = duration;\r\n      \r\n      // Update agent status back to idle\r\n      agent.status = AgentStatus.IDLE;\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      logger.error(`Error executing agent ${request.agentId}:`, error);\r\n      \r\n      // Update agent status to error\r\n      agent.status = AgentStatus.ERROR;\r\n      \r\n      return {\r\n        agentId: request.agentId,\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute with OpenAI API\r\n   */\r\n  private async executeOpenAI(\r\n    agent: Agent,\r\n    request: AgentExecutionRequest\r\n  ): Promise<AgentExecutionResult> {\r\n    if (!this.openaiClient) {\r\n      return {\r\n        agentId: agent.id,\r\n        success: false,\r\n        error: 'OpenAI client not initialized. Missing API key.'\r\n      };\r\n    }\r\n\r\n    try {\r\n      const completion = await this.openaiClient.chat.completions.create({\r\n        messages: [\r\n          { role: 'system', content: request.systemInstructions || 'You are a helpful AI agent.' },\r\n          { role: 'user', content: request.prompt }\r\n        ],\r\n        model: agent.modelName,\r\n        temperature: request.temperature || 0.7,\r\n        max_tokens: request.maxTokens || 1024,\r\n        // tools: request.tools // Enable if tools are supported by the agent and model\r\n      });\r\n\r\n      const output = completion.choices[0]?.message?.content || '';\r\n      const usage = completion.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };\r\n\r\n      return {\r\n        agentId: agent.id,\r\n        success: true,\r\n        output,\r\n        usage: {\r\n          promptTokens: usage.prompt_tokens,\r\n          completionTokens: usage.completion_tokens,\r\n          totalTokens: usage.total_tokens\r\n        },\r\n        metadata: {\r\n          model: agent.modelName,\r\n          brand: request.brandContext,\r\n          finishReason: completion.choices[0]?.finish_reason\r\n        }\r\n      };\r\n    } catch (error) {\r\n      logger.error(`OpenAI execution error for agent ${agent.id}:`, error);\r\n      return {\r\n        agentId: agent.id,\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute with Anthropic API\r\n   */\r\n  private async executeAnthropic(\r\n    agent: Agent,\r\n    request: AgentExecutionRequest\r\n  ): Promise<AgentExecutionResult> {\r\n    if (!this.anthropicClient) {\r\n      return {\r\n        agentId: agent.id,\r\n        success: false,\r\n        error: 'Anthropic client not initialized. Missing API key.'\r\n      };\r\n    }\r\n\r\n    try {\r\n      const response = await this.anthropicClient.messages.create({\r\n        model: agent.modelName,\r\n        max_tokens: request.maxTokens || 1024,\r\n        temperature: request.temperature || 0.7,\r\n        system: request.systemInstructions || 'You are a helpful AI agent.',\r\n        messages: [\r\n          { role: 'user', content: request.prompt }\r\n        ]\r\n      });\r\n\r\n      const output = response.content.map(block => block.text).join('\\n');\r\n      const usage = response.usage;\r\n\r\n      return {\r\n        agentId: agent.id,\r\n        success: true,\r\n        output,\r\n        usage: {\r\n          promptTokens: usage.input_tokens,\r\n          completionTokens: usage.output_tokens,\r\n          totalTokens: usage.input_tokens + usage.output_tokens\r\n        },\r\n        metadata: {\r\n          model: agent.modelName,\r\n          brand: request.brandContext,\r\n          stopReason: response.stop_reason\r\n        }\r\n      };\r\n    } catch (error) {\r\n      logger.error(`Anthropic execution error for agent ${agent.id}:`, error);\r\n      return {\r\n        agentId: agent.id,\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute with Ollama API\r\n   */\r\n  private async executeOllama(\r\n    agent: Agent,\r\n    request: AgentExecutionRequest\r\n  ): Promise<AgentExecutionResult> {\r\n    const ollamaBaseUrl = getOptionalEnv('OLLAMA_BASE_URL', 'http://localhost:11434');\r\n    try {\r\n      const response = await fetch(`${ollamaBaseUrl}/api/chat`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          model: agent.modelName,\r\n          messages: [\r\n            { role: 'system', content: request.systemInstructions || 'You are a helpful AI agent.' },\r\n            { role: 'user', content: request.prompt }\r\n          ],\r\n          options: {\r\n            temperature: request.temperature || 0.7,\r\n            num_ctx: request.maxTokens || 1024, // Ollama uses num_ctx for context window size, which is similar to max_tokens\r\n          },\r\n          stream: false,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        throw new Error(`Ollama API error: ${response.status} ${response.statusText} - ${errorText}`);\r\n      }\r\n\r\n      const data: OllamaChatResponse = await response.json();\r\n      const output = data.message?.content || '';\r\n      const usage = data.usage || { prompt_eval_count: 0, eval_count: 0, total_eval_count: 0 };\r\n\r\n      return {\r\n        agentId: agent.id,\r\n        success: true,\r\n        output,\r\n        usage: {\r\n          promptTokens: usage.prompt_eval_count, // Ollama uses prompt_eval_count for prompt tokens\r\n          completionTokens: usage.eval_count,    // Ollama uses eval_count for completion tokens\r\n          totalTokens: usage.total_eval_count     // Ollama uses total_eval_count for total tokens\r\n        },\r\n        metadata: {\r\n          model: agent.modelName,\r\n          brand: request.brandContext,\r\n        }\r\n      };\r\n    } catch (error) {\r\n      logger.error(`Ollama execution error for agent ${agent.id}:`, error);\r\n      return {\r\n        agentId: agent.id,\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute with Custom Model (placeholder for generic API interaction)\r\n   */\r\n  private async executeCustom(\r\n    agent: Agent,\r\n    request: AgentExecutionRequest\r\n  ): Promise<AgentExecutionResult> {\r\n    logger.warn(`Custom model execution for agent ${agent.id} is being handled generically.`);\r\n    // This could be extended to handle various custom API endpoints or local models\r\n    // For now, it acts as a placeholder for future custom integrations.\r\n    // You might integrate with a dynamic loader or a configuration-driven API client here.\r\n    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API latency\r\n    \r\n    return {\r\n      agentId: agent.id,\r\n      success: true,\r\n      output: `[Custom Model] Processed: ${request.prompt} with model ${agent.modelName}`,\r\n      usage: {\r\n        promptTokens: request.prompt.length,\r\n        completionTokens: Math.floor(request.prompt.length / 5), // Arbitrary\r\n        totalTokens: request.prompt.length + Math.floor(request.prompt.length / 5)\r\n      },\r\n      metadata: {\r\n        model: agent.modelName,\r\n        brand: request.brandContext\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update agent status\r\n   */\r\n  public updateAgentStatus(agentId: string, status: AgentStatus): boolean {\r\n    const agent = this.agents.get(agentId);\r\n    \r\n    if (!agent) {\r\n      return false;\r\n    }\r\n    \r\n    agent.status = status;\r\n    agent.lastActive = new Date();\r\n    \r\n    logger.info(`Updated agent ${agentId} status to ${status}`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove an agent\r\n   */\r\n  public removeAgent(agentId: string): boolean {\r\n    const agent = this.agents.get(agentId);\r\n    \r\n    if (!agent) {\r\n      return false;\r\n    }\r\n    \r\n    // Remove from all indexes\r\n    agent.capabilities.forEach(capability => {\r\n      this.capabilityIndex.get(capability)?.delete(agentId);\r\n    });\r\n    \r\n    this.typeIndex.get(agent.type)?.delete(agentId);\r\n    this.modelProviderIndex.get(agent.modelProvider)?.delete(agentId);\r\n    \r\n    // Remove from main map\r\n    this.agents.delete(agentId);\r\n    \r\n    logger.info(`Removed agent ${agentId}`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get all registered agents\r\n   */\r\n  public getAllAgents(): Agent[] {\r\n    return Array.from(this.agents.values());\r\n  }\r\n\r\n  /**\r\n   * Get agent stats\r\n   */\r\n  public getAgentStats(): Record<string, any> {\r\n    const totalAgents = this.agents.size;\r\n    const agentsByType = Object.values(AgentType).reduce((acc, type) => {\r\n      acc[type] = this.typeIndex.get(type)?.size || 0;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n    \r\n    const agentsByStatus = Object.values(AgentStatus).reduce((acc, status) => {\r\n      acc[status] = Array.from(this.agents.values()).filter(\r\n        agent => agent.status === status\r\n      ).length;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n    \r\n    const agentsByModelProvider = Object.values(ModelProvider).reduce((acc, provider) => {\r\n      acc[provider] = this.modelProviderIndex.get(provider)?.size || 0;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n    \r\n    return {\r\n      totalAgents,\r\n      agentsByType,\r\n      agentsByStatus,\r\n      agentsByModelProvider\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet agentManager: AgentManager | null = null;\r\n\r\n/**\r\n * Initialize the agent manager\r\n */\r\nexport async function initializeAgentManager(): Promise<AgentManager> {\r\n  if (!agentManager) {\r\n    agentManager = new AgentManager();\r\n    \r\n    // Register default agents based on configuration\r\n    const registerDefaultAgents = getOptionalEnv('REGISTER_DEFAULT_AGENTS', 'true') === 'true';\r\n    \r\n    if (registerDefaultAgents) {\r\n      // Register brand context agent\r\n      agentManager.registerAgent({\r\n        name: 'Brand Context Manager',\r\n        type: AgentType.BRAND_CONTEXT,\r\n        capabilities: [\r\n          AgentCapability.CONTEXT_VALIDATION,\r\n          AgentCapability.REASONING\r\n        ],\r\n        modelProvider: ModelProvider.OPENAI,\r\n        modelName: 'gpt-4'\r\n      });\r\n      \r\n      // Register content generation agent\r\n      agentManager.registerAgent({\r\n        name: 'Content Generator',\r\n        type: AgentType.CONTENT_GENERATION,\r\n        capabilities: [\r\n          AgentCapability.CONTENT_GENERATION,\r\n          AgentCapability.CODE_GENERATION\r\n        ],\r\n        modelProvider: ModelProvider.ANTHROPIC,\r\n        modelName: 'claude-3-opus-20240229'\r\n      });\r\n      \r\n      // Register workflow orchestration agent\r\n      agentManager.registerAgent({\r\n        name: 'Workflow Orchestrator',\r\n        type: AgentType.WORKFLOW_ORCHESTRATION,\r\n        capabilities: [\r\n          AgentCapability.WORKFLOW_ORCHESTRATION,\r\n          AgentCapability.PLANNING\r\n        ],\r\n        modelProvider: ModelProvider.OPENAI,\r\n        modelName: 'gpt-4-turbo'\r\n      });\r\n      \r\n      // Register analytics agent\r\n      agentManager.registerAgent({\r\n        name: 'Analytics Agent',\r\n        type: AgentType.ANALYTICS,\r\n        capabilities: [\r\n          AgentCapability.ANALYTICS,\r\n          AgentCapability.REASONING\r\n        ],\r\n        modelProvider: ModelProvider.ANTHROPIC,\r\n        modelName: 'claude-3-sonnet-20240229'\r\n      });\r\n      \r\n      // Register asset management agent\r\n      agentManager.registerAgent({\r\n        name: 'Asset Manager',\r\n        type: AgentType.ASSET_MANAGEMENT,\r\n        capabilities: [\r\n          AgentCapability.ASSET_MANAGEMENT\r\n        ],\r\n        modelProvider: ModelProvider.OLLAMA,\r\n        modelName: 'llama3'\r\n      });\r\n      \r\n      logger.info('Registered default agents');\r\n    }\r\n  }\r\n  \r\n  return agentManager;\r\n}\r\n\r\n/**\r\n * Get the agent manager instance\r\n */\r\nexport function getAgentManager(): AgentManager {\r\n  if (!agentManager) {\r\n    throw new Error('Agent Manager not initialized. Call initializeAgentManager() first.');\r\n  }\r\n  \r\n  return agentManager;\r\n}\r\n"],"mappings":"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","names":["Hono","agent","Hono","AgentCapability","AgentStatus","AgentType","ModelProvider","taskQueueSystem","agentManager"]}